# 4章 クラスとインターフェース
## クラスとメンバーへのアクセス可能性を最小限にする　
* カプセル化する
	* モジュール毎に開発、テスト、最適化、修正が可能になる
* 各クラスやメンバーを出来る限りアクセスできないようにすべき
* トップレベルのクラスやインターフェースをpackage-privateにすればパッケージの実装一部になるため、修正が容易
	* 逆にpublicにすると互換性維持の必要があるため、永久にサポートする必要がある
	* トップレベルのpackage-privateなクラスを１つのクラスだけが使用しているならprivateなインナークラスにしたほうが良い
* インスタンスフィールドはpublicにするべきではない
* 配列やリストを返すpublic static finalなフィールドは利用側から変更可能なため危険
	* privateに変更しpublicな不変リストを返すようにする
	* 配列のcloneを返す
	
```
// 不変リストを返す
private static final String PRIVATE_VALUES = {...}
public static final List<String> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

// cloneを返す
public static final String[] values() {
	return PRIVATE_VALUES.clone();
}
```

## publicのクラスはpublicフィールドではなくアクセッサーメソッドを使う
* フィールドが変更された時に何らかの処理を入れることが出来る
* package-privateなクラスや、privateなインナークラスであればpublicなフィールドにしても大きな問題ではない。
	* パッケージやクラス内で完結するため
	
## 可変性を最小限にする
* 不変クラスはインスタンスが変更できないクラス
* クラスを不変にしたほうが設計、実装、使用が可変クラスよりも容易
* 不変クラスにする5つの規則
	* セッターなどの状態を変更するメソッドを提供しない
	* finalクラスにして継承できないようにする
	* フィールドをfinalにする
	* フィールドをprivateにする
	* 可変コンポーネントに対する独占的アクセスを保証する

## 継承よりコンポジションを選ぶ
* 継承は強力だけど安易な使用は避けたほうが良い
* 継承が適切な場合
	* スーパークラスが継承されることを意図して作成されている
	* サブクラスに求めることがきちんとドキュメント化されている
	* サブクラスとスーパークラスの間に"is-a"関係が成り立つ（全てのサブクラスは本当にスーパークラスであるか？を考える） 
* コンポジションを使う
	* 既存クラスのインスタンスを持つprivateなフィールドを新しいクラス(転送クラス)に持たせる
	* 転送クラスのメソッドは保持している既存クラスのインスタンスに対応したメソッドを呼び出し、その結果を返す	

![image](/Users/tanakatatsuya/Documents/markdown/Chapter4_16.png)

## 抽象クラスよりインタフェースを選ぶ
* クラスは１つの親しか持てない
* 既存のクラスに新しい機能を増やす
	* インタフェースであれば`implements`して処理を書くだけ
	* 抽象クラスの場合、機能の有無に関わらず継承しているクラス全てに実装されてしまう
* インタフェース毎に骨格実装クラスを提供するとインターフェースと抽象クラスの長所を組み合わせられる
	* 骨格実装クラスは`Abstract"Interface名"`で宣言されてる(AbstractCollectionなど)
	* 骨格実装を使うとインタフェースの独自実装が簡単になる
	* 骨格実装は無名クラスで
	* 擬似多重継承を実現することができる
* インタフェースは一度リリースされ、広く実装されると変更することは不可能に近いので注意

## 型を定義するためだけにインタフェースを使用する
* インターフェースは実装クラスの型として使用できる
* 定数インターフェースはNG！
	* 定数をクラスの内部で使用するのは実装の詳細となるためインタフェースに反する
	* 定数ユーティリティクラスを利用する

## タグ付クラスよりクラス階層を選ぶ
* タグ付クラス
	* クラス内に複数の状態を持つクラス（例えば円か四角を表現できるクラス）
	* このクラスはswitch文を利用して状態に合わせた値を返すコードが増える
	* 不要なフィールドをインスタンスに保持するため、メモリ量が増える
* 状態をクラスに分けることでタグ付クラスの欠点を正せる
* タグ付けクラスを利用したくなったら、クラス階層を利用できないか検討する


## 戦略を表現するために関数オブジェクトを使用する
* 

## 非staticのメンバークラスよりstaticのメンバークラスを選ぶ

## 